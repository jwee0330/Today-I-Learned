## 배열
- 데이터를 나열하고, 각 데이터를 인덱스에 대응하도록 구성한 데이터 구조
배열이란 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 말한다. 많은 양의 데이터를 저장하기 위해서,
그 데이터의 숫자만큼 변수를 선언해야 한다면 매우 혼란스러울 것이다. 배열은 같은 타입의 여러 변수를 하나의 묶음으로
다루는 것이다. 변수와 달리 배열은 JVM 에서 각 저장공간이 연속적으로 배치되어 있다는 특징이 있다.

## 배열은 왜 필요할까?
- 같은 종류의 데이터를 효율적으로 관리하기 위해 사용
- 같은 종류의 데이터를 순차적으로 저장
### 장점
- 빠른 접근 가능
  - 첫 데이터의 위치에서 상대적인 위치로 데이터 접근(인덱스 번호로 접근)
### 단점
- 데이터 추가/삭제의 어려움
  - 미리 최대 길이를 지정해야 함

#### 배열의 선언과 생성
1. 타입[] 변수이름;
2. 타입 변수이름[];

#### 배열의 길이와 인덱스
생성된 배열의 각 저장공간을 '배열의 요소(element)'라고 하며, '배열이름[인덱스]'의 형식으로 배열의 요소에 접근한다.
인덱스(index)는 배열의 요소마다 붙여진 일련번호로 각 요소를 구별하는데 사용된다.  
`인덱스의 범위는 0부터 '배열길이 - 1'까지 이다.`

#### 배열이름.length
자바에서는 JVM이 모든 배열의 길이를 별도로 관리하며, 이를 '배열이름.length'를 통해서 배열의 길이에 대한 정보를 얻을 수 있다.  
배열은 한번 생성하면 길이를 변경할 수 없기 때문에, 이미 생성된 배열의 길이는 변하지 않는다. 따라서, '배열이름.length'는 상수이다.  
즉, 값을 읽을 수만 있을 뿐 변경할 수 없다.

* 배열의 길이를 변경하는 방법:
  1. 더큰 배열을 새로 생성한다.
  2. 기존 배열의 내용을 새로운 배열에 복사한다.

#### 배열의 초기화
배열은 생성과 동시에 자동적으로 자신의 타입에 해당하는 기본값으로 초기화되므로 배열을 사용하기 전에 따로 초기화를 해주지 않아도 되지만,
원하는 값을 저장하려면 각 요소마다 값을 지정해 줘야한다.
`int[] array = new int[원하는 배열의 사이즈];` 로 생성  
생성하면서 초기화 하고 싶은경우 `int[] array = new int[] {1, 2, 30, 40, 50};` 혹은   
`int[] array = {1, 2, 30, 40, 50};`으로 단축가능 그러나 선언과 초기화를 따로 할 때는 불가능하다
```
int[] array;
array = {1, 2, 30, 50, 60}; // 선언과 초기화 따로할 때 에러 new int[] 생략할 수 없음
```
#### 배열의 복사
배열은 한번 생성하면 그 길이를 변경할 수 없기 때문에 더 많은 저장공간이 필요하다면 보다 큰 배열을 새로 만들고
이전 배열로부터 내용을 복사해야한다고 했다. 배열을 복사하는 방법은 두 가지가 있는데, for문을 이용해서 배열을 복사하는 방법과
System.arraycopy()를 이용한 배열의 복사 방법이 있다. 결론부터 말하자면   
`배열의 복사는 for문보다 System.arraycopy()를 사용하는 것이 효율적이다.`  
  
- for문 으로 복사
```java
int[] arr = new int[5];
int[] tmp = new int[arr.length * 2]; // 기존 배열보다 길이가 2배인 배열 생성
for(int i = 0; i < arr.length; i++) {
  tmp[i] = arr[i]; // arr[i]의 값을 tmp[i]에 저장
}
arr = tmp; // 참조변수 arr이 새로운 배열을 가리키게 한다.
```
***[참고] 배열은 참조변수를 통해서만 접근할 수 있기 때문에, 자신을 가리키는 참조변수가 없는 배열은 사용할 수 없다. 
이렇게 쓸모없게 된 배열은 JVM의 가비지 컬렉터에 의해서 자동적으로 메모리에서 제거된다.***

- System.arraycopy()를 이용한 배열의 복사
`System.arraycopy(array, 0, newArray, 0, length);`  
array[0]에서 newArray[0]으로 length개의 데이터를 복사

#### 배열의 활용
1. 총합과 평균
    - 배열의 모든 요소를 더해서 총합과 평균을 구한다.
2. 최대값과 최소값
    - 배열의 요수 중에서 제일 큰 값과 제일 작은 값을 찾는다.
3. 섞기(shuffle)
    - 배열의 요소의 순서를 반복해서 바꾼다. (카드섞기, 로또번호생성)  
4. 임의의 값으로 배열 채우기
    - 연속 또는 불연속적인 값들로 배열을 초기화한다.
5. 정렬하기(sort)
    - 오름차순, 내림차순으로 배열을 정렬
6. 빈도수 구하기
    - 배열에 어떤 값이 몇개 저장되어 있는지 세어서 보여준다.

## 다차원 배열
위에 설명한 배열은 1차원 배열인데, 2차원 이상의 배열, 즉 다차원 배열도 선언해서 사용할 수 있다.
메모리의 용량이 허용하는 한, 차원의 제한은 없지만, 주로 1, 2차원 배열이 사용된다.

#### 2차원 배열의 선언과 인덱스
2차원 배열을 선언하는 방법  

| 선언방법 | 선언 예 |
|----------|---------|
| 타입[][] 변수이름; | int[][] score; |
| 타입 변수이름[][]; | int score[][]; |
| 타입[] 변수이름[]; | int[] socre[]; |

#### 2차원 배열의 초기화
2차원 배열도 괄호{}를 사용해서 생성과 초기화를 동시에 할 수 있다. 다만, 1차원 배열보다 괄호 {}를 한번 더 써서 구분해준다.
```java
int[][] arr = new int[][] { {1,2,3}, {4,5,6} };
int[][] arr = { {1,2,3}, {4,5,6} };
```

#### 다차원 배열의 활용
1. 좌표에 X표하기
    - 입력한 2차원 좌표의 위치에 X를 표시
2. 빙고
    - 빙고판을 만들고 입력받은 숫자를 빙고판에서 지운다.
3. 행렬의 곱셈
    - 두 행렬(matrix)을 곱한 결과를 출력
4. 단어 맞추기
    - 영어 단어를 보여주고, 뜻을 맞추는 게임

## 리스트
자료구조 리스트의 인터페이스
구현체로는
**AbstractList** 를 구현한 **ArrayList**, **Vector**   
**Vector** 를 *LIFO(last-in-first-out)* 자료구조를 표현할 수 있도록 상속받은 **Stack**  
- 보다 완전하고 일관된 *LIFO* 스택 작업은 **Deque** 인터페이스 및 해당 구현에 의해 제공되며, **Stack** 클래스보다 우선적으로 사용하는것이 권장된다.  
  
**SequancialAbstractlist** 를 구현한 **LinkedList**  
**ArrayList** 의 동시성 문제 해결을 위한 concurrent package 의 **CopyOnWriteArrayList** 등이 있다.

### ArrayList

### Vector

### Stack

### LinkedList

### CopyOnWriteArrayList

#### 참조
- [https://docs.oracle.com/javase/8/docs/api/index.html](https://docs.oracle.com/javase/8/docs/api/index.html)
